% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fuse.R
\name{parse_rmd}
\alias{parse_rmd}
\title{Parse an R Markdown document}
\usage{
parse_rmd(input = NULL, text = xfun::read_utf8(input))
}
\arguments{
\item{input}{The input file.}

\item{text}{A character vector of the Rmd source. If provided, the \code{input}
argument will be ignored.}
}
\value{
A list of code chunks and text blocks:

Code chunks are of the form \code{list(source, type = "code_chunk", options, comments, ...)}: \code{source} is a character vector of the source code of a
code chunk, \code{options} is a list of chunk options, and \code{comments} is a
vector of pipe comments.

Text blocks are of the form \code{list(source, type = "text_block", ...)}. If
the text block does not contain any inline code, \code{source} will be a
character string (lines of text concatenated by line breaks), otherwise it
will be a list with members that are either character strings (normal text
fragments) or lists of the form \code{list(code, options)} (\code{code} is the inline
code, and \code{options} contains its options specified inside \code{`{lang, ...}`}).

Both code chunks and text blocks have a list member named \code{lines} that
stores their line numbers in the input.

If any code chunks have labels (specified via the chunk option \code{label}),
the whole returned list will be named using the labels.
}
\description{
Parse an Rmd document into code chunks, inline code expressions, and text
fragments.
}
\details{
A code chunk must start with a fence of the form \verb{```\{lang\}}, where
\code{lang} is the language name, e.g., \code{r} or \code{python}. The body of a code chunk
can start with chunk options written in "pipe comments", e.g., \verb{#| eval = TRUE, echo = FALSE} (the CSV syntax) or \verb{#| eval: true} (the YAML syntax).

An inline code fragment is of the form \code{`{lang} code`} embedded in
Markdown text.
}
\examples{
res = litedown::parse_rmd(text = c("```{r}\n1+1\n```",
    "Hello, `pi` = `{r} pi` and `e` = `{r} exp(1)`!"))
str(res)
# evaluate inline code and combine results with text
# fragments
txt = lapply(res[[2]]$source, function(x) {
    if (is.character(x))
        x else eval(parse(text = x$code))
})
paste(unlist(txt), collapse = "")
}
